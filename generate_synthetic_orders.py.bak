#!/usr/bin/env python3
"""
Synthetic Orders Data Generator for Toys for Kids
Generates realistic sales data with weekend spikes and monthly growth patterns
"""

import csv
import json
import random
import string
from datetime import datetime, timedelta
from typing import List, Dict, Tuple
import math
import holidays
import os

def load_config():
    """Load configuration from config.json file."""
    config_path = os.path.join(os.path.dirname(__file__), 'config.json')
    try:
        with open(config_path, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"⚠️  Config file not found at {config_path}. Using default values.")
        return {}
    except json.JSONDecodeError as e:
        print(f"⚠️  Error parsing config file: {e}. Using default values.")
        return {}

# Load configuration
CONFIG = load_config()

# Configuration Variables - loaded from config.json or using defaults
NUMBER_OF_MONTHS = CONFIG.get('data_generation', {}).get('number_of_months', 12)
AVERAGE_MONTHLY_GROWTH = CONFIG.get('data_generation', {}).get('average_monthly_growth', 0.08)
WEEKEND_BOOST_FACTOR = CONFIG.get('data_generation', {}).get('weekend_boost_factor', 1.8)
BASE_DAILY_ORDERS = CONFIG.get('data_generation', {}).get('base_daily_orders', 15)
SEASONAL_FACTOR = CONFIG.get('data_generation', {}).get('seasonal_factor', 0.3)

# Number of SKUs to generate (loaded from config)
NUMBER_OF_SKUS = CONFIG.get('data_generation', {}).get('number_of_skus', 50)

# Enhanced Prophet Learning Patterns
ENABLE_STRONG_PATTERNS = True  # Enable stronger patterns for Prophet to learn
AUTOCORRELATION_FACTOR = 0.3  # How much previous days affect current day
CYCLICAL_PATTERNS = True  # Enable cyclical demand patterns
TREND_STRENGTH = 0.4  # How strong trending signals should be

# Prophet Model Compatibility Settings - loaded from config.json or using defaults
MIN_SALES_DAYS_PER_SKU = CONFIG.get('prophet_optimization', {}).get('min_sales_days_per_sku', 30)
MIN_TOTAL_UNITS_PER_SKU = CONFIG.get('prophet_optimization', {}).get('min_total_units_per_sku', 50)
ENSURE_SKU_DISTRIBUTION = CONFIG.get('prophet_optimization', {}).get('ensure_sku_distribution', True)
SKU_POPULARITY_WEIGHTS = CONFIG.get('prophet_optimization', {}).get('sku_popularity_weights', True)

# New Discount Configuration for Prophet Training Data - loaded from config.json
ENABLE_DISCOUNTS = CONFIG.get('discounts', {}).get('enable_discounts', True)

# Discount ratio configuration - simplified for Prophet model
config_discount_probs = CONFIG.get('discounts', {}).get('discount_ratio_probabilities', {})
DISCOUNT_RATIO_PROBABILITIES = {}
for ratio_str, prob in config_discount_probs.items():
    DISCOUNT_RATIO_PROBABILITIES[float(ratio_str)] = prob

# Default discount probabilities if not in config
if not DISCOUNT_RATIO_PROBABILITIES:
    DISCOUNT_RATIO_PROBABILITIES = {
        0.00: 0.75,   # 75% of orders have no discount (most common)
        0.10: 0.08,   # 8% have 10% discount (light promotions)
        0.15: 0.06,   # 6% have 15% discount
        0.20: 0.05,   # 5% have 20% discount
        0.25: 0.03,   # 3% have 25% discount
        0.30: 0.02,   # 2% have 30% discount (seasonal sales)
        0.40: 0.005,  # 0.5% have 40% discount (rare big promotions)
        0.50: 0.005,  # 0.5% have 50% discount (very rare deep promotions)
    }

# Quantity Variety Settings for Better ML Performance - loaded from config.json
ENABLE_QUANTITY_VARIETY = CONFIG.get('quantity_settings', {}).get('enable_quantity_variety', True)
MIN_QUANTITY = CONFIG.get('quantity_settings', {}).get('min_quantity', 0)
MAX_QUANTITY = CONFIG.get('quantity_settings', {}).get('max_quantity', 8)
STOCK_OUT_PROBABILITY = CONFIG.get('quantity_settings', {}).get('stock_out_probability', 0.05)
BULK_ORDER_PROBABILITY = CONFIG.get('quantity_settings', {}).get('bulk_order_probability', 0.20)
LOW_INVENTORY_PROBABILITY = CONFIG.get('quantity_settings', {}).get('low_inventory_probability', 0.15)
HIGH_DEMAND_SPIKE_PROBABILITY = CONFIG.get('quantity_settings', {}).get('high_demand_spike_probability', 0.10)

# Realism Layer Configuration - loaded from config.json
ENABLE_REALISM_LAYER = CONFIG.get('realism_layer', {}).get('enable_realism_layer', True)

# Data Quality Issues Configuration
MISSING_EMAIL_PROB = CONFIG.get('realism_layer', {}).get('data_quality_issues', {}).get('missing_email_probability', 0.05)
MISSING_PHONE_PROB = CONFIG.get('realism_layer', {}).get('data_quality_issues', {}).get('missing_phone_probability', 0.12)
INCOMPLETE_ADDRESS_PROB = CONFIG.get('realism_layer', {}).get('data_quality_issues', {}).get('incomplete_address_probability', 0.08)
DUPLICATE_ORDER_PROB = CONFIG.get('realism_layer', {}).get('data_quality_issues', {}).get('duplicate_order_probability', 0.002)
PROCESSING_DELAY_PROB = CONFIG.get('realism_layer', {}).get('data_quality_issues', {}).get('processing_delay_probability', 0.15)
FULFILLMENT_DELAY_PROB = CONFIG.get('realism_layer', {}).get('data_quality_issues', {}).get('fulfillment_delay_probability', 0.20)

# Business Irregularities Configuration
INVENTORY_STOCKOUT_PROB = CONFIG.get('realism_layer', {}).get('business_irregularities', {}).get('inventory_stockout_days', 0.03)
SYSTEM_DOWNTIME_PROB = CONFIG.get('realism_layer', {}).get('business_irregularities', {}).get('system_downtime_probability', 0.008)
MANUAL_ORDER_ENTRY_PROB = CONFIG.get('realism_layer', {}).get('business_irregularities', {}).get('manual_order_entry_probability', 0.05)
BULK_B2B_ORDER_PROB = CONFIG.get('realism_layer', {}).get('business_irregularities', {}).get('bulk_b2b_order_probability', 0.02)
RETURN_PROCESSING_PROB = CONFIG.get('realism_layer', {}).get('business_irregularities', {}).get('return_processing_days', 0.015)
PAYMENT_FAILURE_PROB = CONFIG.get('realism_layer', {}).get('business_irregularities', {}).get('payment_failure_probability', 0.025)

# Sales Anomalies Configuration
VIRAL_SPIKE_PROB = CONFIG.get('realism_layer', {}).get('sales_anomalies', {}).get('viral_product_spike_probability', 0.001)
SOCIAL_MEDIA_BOOST_PROB = CONFIG.get('realism_layer', {}).get('sales_anomalies', {}).get('social_media_boost_probability', 0.005)
COMPETITOR_IMPACT_PROB = CONFIG.get('realism_layer', {}).get('sales_anomalies', {}).get('competitor_impact_drop_probability', 0.003)
SUPPLY_CHAIN_DISRUPTION_PROB = CONFIG.get('realism_layer', {}).get('sales_anomalies', {}).get('supply_chain_disruption_probability', 0.002)
SEASONAL_DEVIATION = CONFIG.get('realism_layer', {}).get('sales_anomalies', {}).get('seasonal_trend_deviation', 0.15)
EXTERNAL_EVENT_PROB = CONFIG.get('realism_layer', {}).get('sales_anomalies', {}).get('random_external_event_probability', 0.004)

# Merchant Behavior Configuration
PRICE_ADJUSTMENT_PROB = CONFIG.get('realism_layer', {}).get('merchant_behavior', {}).get('price_adjustment_probability', 0.02)
NEW_PRODUCT_LAUNCH_PROB = CONFIG.get('realism_layer', {}).get('merchant_behavior', {}).get('new_product_launch_probability', 0.008)
DISCONTINUED_PRODUCT_PROB = CONFIG.get('realism_layer', {}).get('merchant_behavior', {}).get('discontinued_product_probability', 0.005)
MARKETING_CAMPAIGN_PROB = CONFIG.get('realism_layer', {}).get('merchant_behavior', {}).get('marketing_campaign_probability', 0.012)
FLASH_SALE_PROB = CONFIG.get('realism_layer', {}).get('merchant_behavior', {}).get('flash_sale_probability', 0.006)
INFLUENCER_COLLAB_PROB = CONFIG.get('realism_layer', {}).get('merchant_behavior', {}).get('influencer_collaboration_probability', 0.003)

# Technical Imperfections Configuration
TIMESTAMP_DRIFT_SECONDS = CONFIG.get('realism_layer', {}).get('technical_imperfections', {}).get('timestamp_drift_seconds', 300)
ORDER_ID_GAPS_PROB = CONFIG.get('realism_layer', {}).get('technical_imperfections', {}).get('order_id_gaps_probability', 0.01)
DUPLICATE_SKU_ENTRIES_PROB = CONFIG.get('realism_layer', {}).get('technical_imperfections', {}).get('duplicate_sku_entries_probability', 0.002)
ROUNDING_ERRORS_PROB = CONFIG.get('realism_layer', {}).get('technical_imperfections', {}).get('rounding_errors_probability', 0.05)
TIMEZONE_INCONSISTENCY_PROB = CONFIG.get('realism_layer', {}).get('technical_imperfections', {}).get('timezone_inconsistency_probability', 0.03)
EXPORT_CORRUPTION_PROB = CONFIG.get('realism_layer', {}).get('technical_imperfections', {}).get('export_corruption_probability', 0.001)

# Quantity patterns based on product popularity and demand
QUANTITY_PATTERNS = {
    'high_demand': {'weights': [0.03, 0.12, 0.25, 0.30, 0.20, 0.08, 0.02], 'values': [0, 1, 2, 3, 4, 5, 6]},
    'medium_demand': {'weights': [0.05, 0.20, 0.35, 0.25, 0.12, 0.03], 'values': [0, 1, 2, 3, 4, 5]},
    'low_demand': {'weights': [0.15, 0.40, 0.25, 0.15, 0.05], 'values': [0, 1, 2, 3, 4]},
    'variable': {'weights': [0.10, 0.18, 0.22, 0.20, 0.15, 0.10, 0.05], 'values': [0, 1, 2, 3, 4, 5, 6]}
}

# Realism Layer State Tracking
realism_state = {
    'viral_products': set(),
    'stockout_products': set(),
    'price_adjusted_products': {},
    'system_downtime_periods': [],
    'marketing_campaigns': [],
    'supply_disruptions': set(),
    'order_id_counter': 1000,
    'processing_delays': {},
    'b2b_customers': set()
}

# Toy Products Database - dynamically generated based on config
def generate_toy_products(num_skus):
    """Generate toy products list based on the configured number of SKUs."""
    
    # Base product templates to use for generation
    base_products = [
        {"name": "LEGO Classic Creative Bricks", "price": 29.99, "sku": "TOY-LEGO-001", "vendor": "LEGO Group", "popularity": 0.95, "trend": "stable"},
        {"name": "Barbie Dreamhouse Playset", "price": 199.99, "sku": "TOY-BARB-001", "vendor": "Mattel", "popularity": 0.85, "trend": "growing"},
        {"name": "Hot Wheels Track Builder", "price": 34.99, "sku": "TOY-HW-001", "vendor": "Mattel", "popularity": 0.90, "trend": "stable"},
        {"name": "Monopoly Board Game", "price": 24.99, "sku": "TOY-MONO-001", "vendor": "Hasbro", "popularity": 0.88, "trend": "stable"},
        {"name": "Nerf Elite Blaster", "price": 19.99, "sku": "TOY-NERF-001", "vendor": "Hasbro", "popularity": 0.92, "trend": "growing"},
        {"name": "Play-Doh Creative Set", "price": 15.99, "sku": "TOY-PD-001", "vendor": "Hasbro", "popularity": 0.89, "trend": "stable"},
        {"name": "Fisher-Price Rock-a-Stack", "price": 8.99, "sku": "TOY-FP-001", "vendor": "Fisher-Price", "popularity": 0.75, "trend": "declining"},
        {"name": "Crayola Art Supplies Kit", "price": 22.99, "sku": "TOY-CRAY-001", "vendor": "Crayola", "popularity": 0.82, "trend": "stable"},
        {"name": "Rubik's Cube Classic", "price": 12.99, "sku": "TOY-RUB-001", "vendor": "Spin Master", "popularity": 0.70, "trend": "volatile"},
        {"name": "Transformers Action Figure", "price": 29.99, "sku": "TOY-TRANS-001", "vendor": "Hasbro", "popularity": 0.78, "trend": "stable"},
        {"name": "Pokémon Trading Cards", "price": 4.99, "sku": "TOY-POKE-001", "vendor": "Pokémon Company", "popularity": 0.95, "trend": "growing"},
        {"name": "My Little Pony Figure", "price": 16.99, "sku": "TOY-MLP-001", "vendor": "Hasbro", "popularity": 0.72, "trend": "declining"},
        {"name": "Thomas & Friends Train Set", "price": 39.99, "sku": "TOY-THOMAS-001", "vendor": "Mattel", "popularity": 0.68, "trend": "declining"},
        {"name": "Minecraft Building Set", "price": 44.99, "sku": "TOY-MC-001", "vendor": "LEGO Group", "popularity": 0.87, "trend": "growing"},
        {"name": "Scrabble Junior", "price": 19.99, "sku": "TOY-SCRAB-001", "vendor": "Hasbro", "popularity": 0.60, "trend": "stable"},
        {"name": "UNO Card Game", "price": 7.99, "sku": "TOY-UNO-001", "vendor": "Mattel", "popularity": 0.85, "trend": "stable"},
        {"name": "Jenga Classic Game", "price": 9.99, "sku": "TOY-JENGA-001", "vendor": "Hasbro", "popularity": 0.80, "trend": "stable"},
        {"name": "Peppa Pig Playhouse", "price": 54.99, "sku": "TOY-PEPPA-001", "vendor": "Character Options", "popularity": 0.65, "trend": "declining"},
        {"name": "Disney Princess Doll", "price": 24.99, "sku": "TOY-DISNEY-001", "vendor": "Mattel", "popularity": 0.83, "trend": "stable"},
        {"name": "Spider-Man Action Figure", "price": 18.99, "sku": "TOY-SPIDER-001", "vendor": "Hasbro", "popularity": 0.86, "trend": "growing"},
        {"name": "Frozen Elsa Dress-Up", "price": 32.99, "sku": "TOY-FROZEN-001", "vendor": "Disney", "popularity": 0.81, "trend": "declining"},
        {"name": "Cars Lightning McQueen", "price": 21.99, "sku": "TOY-CARS-001", "vendor": "Mattel", "popularity": 0.77, "trend": "stable"},
        {"name": "Paw Patrol Rescue Vehicle", "price": 26.99, "sku": "TOY-PAW-001", "vendor": "Spin Master", "popularity": 0.84, "trend": "growing"},
        {"name": "Baby Alive Interactive Doll", "price": 49.99, "sku": "TOY-BABY-001", "vendor": "Hasbro", "popularity": 0.69, "trend": "stable"},
        {"name": "Magic 8 Ball", "price": 11.99, "sku": "TOY-MAGIC-001", "vendor": "Mattel", "popularity": 0.55, "trend": "stable"},
        {"name": "Slinky Original", "price": 5.99, "sku": "TOY-SLINK-001", "vendor": "Poof Slinky", "popularity": 0.58, "trend": "declining"},
        {"name": "Connect 4 Game", "price": 14.99, "sku": "TOY-CON4-001", "vendor": "Hasbro", "popularity": 0.74, "trend": "stable"},
        {"name": "Operation Board Game", "price": 16.99, "sku": "TOY-OP-001", "vendor": "Hasbro", "popularity": 0.67, "trend": "stable"},
        {"name": "Risk Strategy Game", "price": 39.99, "sku": "TOY-RISK-001", "vendor": "Hasbro", "popularity": 0.52, "trend": "stable"},
        {"name": "Clue Mystery Game", "price": 19.99, "sku": "TOY-CLUE-001", "vendor": "Hasbro", "popularity": 0.63, "trend": "stable"},
        {"name": "Yahtzee Dice Game", "price": 8.99, "sku": "TOY-YAH-001", "vendor": "Hasbro", "popularity": 0.71, "trend": "stable"},
        {"name": "Twister Floor Game", "price": 12.99, "sku": "TOY-TWIST-001", "vendor": "Hasbro", "popularity": 0.76, "trend": "stable"},
        {"name": "Sorry! Board Game", "price": 17.99, "sku": "TOY-SORRY-001", "vendor": "Hasbro", "popularity": 0.59, "trend": "declining"},
        {"name": "Trouble Pop-O-Matic", "price": 13.99, "sku": "TOY-TROUB-001", "vendor": "Hasbro", "popularity": 0.61, "trend": "stable"},
        {"name": "Guess Who? Game", "price": 11.99, "sku": "TOY-GUESS-001", "vendor": "Hasbro", "popularity": 0.66, "trend": "stable"},
        {"name": "Battleship Strategy Game", "price": 18.99, "sku": "TOY-BATTLE-001", "vendor": "Hasbro", "popularity": 0.64, "trend": "stable"},
        {"name": "Candy Land Adventure", "price": 9.99, "sku": "TOY-CANDY-001", "vendor": "Hasbro", "popularity": 0.79, "trend": "stable"},
        {"name": "Chutes and Ladders", "price": 8.99, "sku": "TOY-CHUTES-001", "vendor": "Hasbro", "popularity": 0.73, "trend": "stable"},
        {"name": "LEGO Friends Heartlake City", "price": 89.99, "sku": "TOY-LEGO-002", "vendor": "LEGO Group", "popularity": 0.75, "trend": "growing"},
        {"name": "LEGO Technic Race Car", "price": 69.99, "sku": "TOY-LEGO-003", "vendor": "LEGO Group", "popularity": 0.68, "trend": "growing"},
        {"name": "K'NEX Building Set", "price": 24.99, "sku": "TOY-KNEX-001", "vendor": "K'NEX", "popularity": 0.48, "trend": "declining"},
        {"name": "Lincoln Logs Cabin", "price": 29.99, "sku": "TOY-LINC-001", "vendor": "K'NEX", "popularity": 0.54, "trend": "declining"},
        {"name": "Tinker Toys Classic Set", "price": 19.99, "sku": "TOY-TINK-001", "vendor": "K'NEX", "popularity": 0.51, "trend": "declining"},
        {"name": "Magna-Tiles Clear Colors", "price": 49.99, "sku": "TOY-MAGNA-001", "vendor": "Magna-Tiles", "popularity": 0.70, "trend": "growing"},
        {"name": "Playmobil Pirate Ship", "price": 79.99, "sku": "TOY-PLAY-001", "vendor": "Playmobil", "popularity": 0.56, "trend": "stable"},
        {"name": "Calico Critters Family", "price": 34.99, "sku": "TOY-CALI-001", "vendor": "Epoch Everlasting Play", "popularity": 0.62, "trend": "stable"},
        {"name": "Shopkins Mini Figures", "price": 6.99, "sku": "TOY-SHOP-001", "vendor": "Moose Toys", "popularity": 0.73, "trend": "declining"},
        {"name": "LOL Surprise Dolls", "price": 9.99, "sku": "TOY-LOL-001", "vendor": "MGA Entertainment", "popularity": 0.88, "trend": "volatile"},
        {"name": "Hatchimals Surprise Egg", "price": 59.99, "sku": "TOY-HATCH-001", "vendor": "Spin Master", "popularity": 0.67, "trend": "declining"},
        {"name": "Fidget Spinner Classic", "price": 3.99, "sku": "TOY-FIDG-001", "vendor": "Various", "popularity": 0.45, "trend": "declining"}
    ]
    
    vendors = ["Hasbro", "Mattel", "LEGO Group", "Fisher-Price", "Spin Master", "Disney", "Crayola", "K'NEX", "Playmobil", "Various"]
    trends = ["stable", "growing", "declining", "volatile"]
    product_types = [
        "Building Set", "Action Figure", "Doll", "Board Game", "Card Game", "Puzzle", "Art Supplies",
        "Educational Toy", "Electronic Toy", "Outdoor Toy", "Vehicle", "Plush Toy", "Dress-Up", "Musical Toy"
    ]
    
    products = []
    
    # Use base products first (up to the number available)
    for i in range(min(num_skus, len(base_products))):
        products.append(base_products[i].copy())
    
    # Generate additional products if needed
    for i in range(len(base_products), num_skus):
        sku_num = i + 1
        product_type = random.choice(product_types)
        vendor = random.choice(vendors)
        
        product = {
            "name": f"{product_type} #{sku_num}",
            "price": round(random.uniform(3.99, 199.99), 2),
            "sku": f"TOY-GEN-{sku_num:03d}",
            "vendor": vendor,
            "popularity": round(random.uniform(0.45, 0.95), 2),
            "trend": random.choice(trends)
        }
        products.append(product)
    
    return products

# Generate TOY_PRODUCTS based on config
TOY_PRODUCTS = generate_toy_products(NUMBER_OF_SKUS)

# Customer database for realistic names and emails
CUSTOMERS = [
    {"name": "Emma Johnson", "email": "emma.johnson@example.com", "phone": "+1234567890"},
    {"name": "Liam Smith", "email": "liam.smith@example.com", "phone": "+1234567891"},
    {"name": "Olivia Williams", "email": "olivia.williams@example.com", "phone": "+1234567892"},
    {"name": "Noah Brown", "email": "noah.brown@example.com", "phone": "+1234567893"},
    {"name": "Ava Jones", "email": "ava.jones@example.com", "phone": "+1234567894"},
    {"name": "Isabella Garcia", "email": "isabella.garcia@example.com", "phone": "+1234567895"},
    {"name": "Sophia Miller", "email": "sophia.miller@example.com", "phone": "+1234567896"},
    {"name": "Jackson Davis", "email": "jackson.davis@example.com", "phone": "+1234567897"},
    {"name": "Mia Rodriguez", "email": "mia.rodriguez@example.com", "phone": "+1234567898"},
    {"name": "Lucas Wilson", "email": "lucas.wilson@example.com", "phone": "+1234567899"},
    {"name": "Charlotte Martinez", "email": "charlotte.martinez@example.com", "phone": "+1234567800"},
    {"name": "Ethan Anderson", "email": "ethan.anderson@example.com", "phone": "+1234567801"},
    {"name": "Amelia Taylor", "email": "amelia.taylor@example.com", "phone": "+1234567802"},
    {"name": "Alexander Thomas", "email": "alexander.thomas@example.com", "phone": "+1234567803"},
    {"name": "Harper Jackson", "email": "harper.jackson@example.com", "phone": "+1234567804"},
]

# Supported Countries Configuration
SUPPORTED_COUNTRIES = ['US', 'CA', 'GB', 'AU']  # Each order is randomly assigned to one of these countries

# Address database with multiple countries
# Each order will randomly select one country and then choose a random address from that country
ADDRESSES = {
    'US': [
        {"street": "123 Maple Street", "city": "Springfield", "zip": "12345", "province": "NY", "country": "US"},
        {"street": "456 Oak Avenue", "city": "Madison", "zip": "53706", "province": "WI", "country": "US"},
        {"street": "789 Pine Road", "city": "Austin", "zip": "73301", "province": "TX", "country": "US"},
        {"street": "321 Elm Street", "city": "Portland", "zip": "97201", "province": "OR", "country": "US"},
        {"street": "654 Cedar Lane", "city": "Denver", "zip": "80202", "province": "CO", "country": "US"},
        {"street": "987 Birch Drive", "city": "Seattle", "zip": "98101", "province": "WA", "country": "US"},
        {"street": "147 Willow Way", "city": "Phoenix", "zip": "85001", "province": "AZ", "country": "US"},
        {"street": "258 Spruce Court", "city": "Miami", "zip": "33101", "province": "FL", "country": "US"},
        {"street": "369 Aspen Place", "city": "Boston", "zip": "02101", "province": "MA", "country": "US"},
        {"street": "741 Poplar Boulevard", "city": "Chicago", "zip": "60601", "province": "IL", "country": "US"},
    ],
    'CA': [
        {"street": "100 King Street", "city": "Toronto", "zip": "M5H 1A1", "province": "ON", "country": "CA"},
        {"street": "200 Robson Street", "city": "Vancouver", "zip": "V6B 2A7", "province": "BC", "country": "CA"},
        {"street": "300 8th Avenue SW", "city": "Calgary", "zip": "T2P 1C5", "province": "AB", "country": "CA"},
        {"street": "400 Portage Avenue", "city": "Winnipeg", "zip": "R3C 0C8", "province": "MB", "country": "CA"},
        {"street": "500 University Avenue", "city": "Toronto", "zip": "M5G 1V7", "province": "ON", "country": "CA"},
        {"street": "600 René-Lévesque Blvd", "city": "Montreal", "zip": "H3B 1H7", "province": "QC", "country": "CA"},
        {"street": "700 Water Street", "city": "St. John's", "zip": "A1E 1B6", "province": "NL", "country": "CA"},
        {"street": "800 Jasper Avenue", "city": "Edmonton", "zip": "T5J 3N4", "province": "AB", "country": "CA"},
        {"street": "900 Georgia Street", "city": "Vancouver", "zip": "V6C 2W6", "province": "BC", "country": "CA"},
        {"street": "1000 Yonge Street", "city": "Toronto", "zip": "M4W 2K2", "province": "ON", "country": "CA"},
    ],
    'GB': [
        {"street": "10 Downing Street", "city": "London", "zip": "SW1A 2AA", "province": "England", "country": "GB"},
        {"street": "15 Baker Street", "city": "London", "zip": "NW1 6XE", "province": "England", "country": "GB"},
        {"street": "20 Princess Street", "city": "Manchester", "zip": "M1 4LY", "province": "England", "country": "GB"},
        {"street": "25 Rose Street", "city": "Edinburgh", "zip": "EH2 2PR", "province": "Scotland", "country": "GB"},
        {"street": "30 Castle Street", "city": "Cardiff", "zip": "CF10 1BH", "province": "Wales", "country": "GB"},
        {"street": "35 High Street", "city": "Birmingham", "zip": "B4 7SL", "province": "England", "country": "GB"},
        {"street": "40 Church Street", "city": "Liverpool", "zip": "L1 3AX", "province": "England", "country": "GB"},
        {"street": "45 Queen Street", "city": "Glasgow", "zip": "G1 3DX", "province": "Scotland", "country": "GB"},
        {"street": "50 Market Street", "city": "Leeds", "zip": "LS1 6DT", "province": "England", "country": "GB"},
        {"street": "55 King Street", "city": "Bristol", "zip": "BS1 4ER", "province": "England", "country": "GB"},
    ],
    'AU': [
        {"street": "123 Collins Street", "city": "Melbourne", "zip": "3000", "province": "VIC", "country": "AU"},
        {"street": "456 George Street", "city": "Sydney", "zip": "2000", "province": "NSW", "country": "AU"},
        {"street": "789 Queen Street", "city": "Brisbane", "zip": "4000", "province": "QLD", "country": "AU"},
        {"street": "321 King William Street", "city": "Adelaide", "zip": "5000", "province": "SA", "country": "AU"},
        {"street": "654 Hay Street", "city": "Perth", "zip": "6000", "province": "WA", "country": "AU"},
        {"street": "987 Elizabeth Street", "city": "Hobart", "zip": "7000", "province": "TAS", "country": "AU"},
        {"street": "147 Smith Street", "city": "Darwin", "zip": "0800", "province": "NT", "country": "AU"},
        {"street": "258 Northbourne Avenue", "city": "Canberra", "zip": "2600", "province": "ACT", "country": "AU"},
        {"street": "369 Flinders Street", "city": "Melbourne", "zip": "3000", "province": "VIC", "country": "AU"},
        {"street": "741 Pitt Street", "city": "Sydney", "zip": "2000", "province": "NSW", "country": "AU"},
    ]
}

def generate_random_id(length: int = 25) -> str:
    """Generate a random alphanumeric ID."""
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def generate_order_id() -> int:
    """Generate a sequential order ID."""
    if not hasattr(generate_order_id, "counter"):
        generate_order_id.counter = 2000
    generate_order_id.counter += 1
    return generate_order_id.counter

def calculate_seasonal_factor(date: datetime) -> float:
    """Calculate seasonal factor with more realistic, less extreme patterns."""
    month = date.month
    day_of_year = date.timetuple().tm_yday
    # Softer seasonal multipliers
    seasonal_multipliers = {
        1: 1.10,   # January
        2: 0.92,   # February
        3: 0.97,   # March
        4: 1.05,   # April
        5: 1.03,   # May
        6: 0.98,   # June
        7: 1.04,   # July
        8: 1.00,   # August
        9: 1.02,   # September
        10: 1.08,  # October
        11: 1.13,  # November
        12: 1.18,  # December
    }
    base_seasonal = seasonal_multipliers.get(month, 1.0)
    # Smoother sinusoidal variation
    yearly_cycle = 1 + 0.12 * math.sin(2 * math.pi * day_of_year / 365.25 + math.pi/2)
    return (base_seasonal + yearly_cycle) / 2

def get_us_holidays(start_date, end_date):
    """Return a set of US holiday dates between start_date and end_date."""
    us_holidays = holidays.country_holidays('US', years=range(start_date.year, end_date.year + 1))
    return set(us_holidays.keys())

def calculate_daily_orders(date: datetime, month_index: int, us_holiday_dates=None, prev_orders: int = None, sku: str = None, sku_trend: float = 0.0, mean_sku_sales: float = 10.0) -> int:
    """Calculate number of orders for a given date with advanced realism: event spikes, trend drift, heteroskedastic noise, and improved outlier smoothing."""
    if us_holiday_dates is None:
        us_holiday_dates = set()
    # --- Trend Drift ---
    drift = sku_trend * (date - (date.replace(month=1, day=1))).days
    # --- Base multipliers ---
    monthly_multiplier = (1 + AVERAGE_MONTHLY_GROWTH * random.uniform(0.92, 1.08)) ** month_index
    weekend_multiplier = 1.18 if date.weekday() >= 5 else 1.0
    seasonal_multiplier = calculate_seasonal_factor(date)
    weekday = date.weekday()
    weekly_pattern = {
        0: 1.0,   # Monday
        1: 1.02,  # Tuesday
        2: 0.98,  # Wednesday
        3: 1.0,   # Thursday
        4: 1.05,  # Friday
        5: 1.18,  # Saturday
        6: 1.12,  # Sunday
    }
    weekly_multiplier = weekly_pattern.get(weekday, 1.0)
    day_of_month = date.day
    if day_of_month <= 10:
        monthly_progression = 0.98
    elif day_of_month <= 20:
        monthly_progression = 1.0
    else:
        monthly_progression = 1.02
    # --- Event/Promotion Spikes ---
    event_multiplier = 1.0
    # 3-day window around major holidays
    for offset in [-1, 0, 1]:
        event_date = date + timedelta(days=offset)
        if event_date in us_holiday_dates:
            if event_date.month == 12 and event_date.day in [24, 25]:
                event_multiplier = max(event_multiplier, random.uniform(1.2, 1.5))
            elif event_date.month == 11 and event_date.day in [24, 25, 26]:
                event_multiplier = max(event_multiplier, random.uniform(1.15, 1.3))
            elif event_date.month == 10 and event_date.day == 31:
                event_multiplier = max(event_multiplier, random.uniform(1.1, 1.2))
    # --- Heteroskedastic Noise ---
    base_orders = (BASE_DAILY_ORDERS * monthly_multiplier * weekend_multiplier * 
                   seasonal_multiplier * weekly_multiplier * monthly_progression * event_multiplier)
    base_orders += drift
    # Mild autocorrelation
    if prev_orders is not None:
        base_orders = 0.5 * base_orders + 0.5 * prev_orders
    # Noise ~ Normal(mean, 0.1*mean)
    noise = random.gauss(0, 0.1 * max(mean_sku_sales, 1))
    # Clamp to reasonable range
    orders = int(max(5, min(40, base_orders + noise)))
    return orders

# Global tracking for quantity patterns per SKU
sku_quantity_history = {}

def generate_varied_quantity(product: Dict, date: datetime, sku_history: List[int] = None) -> int:
    """Generate realistic quantity with heteroskedastic noise and weekday/weekend bias for zeros."""
    if not ENABLE_QUANTITY_VARIETY:
        return random.randint(1, 3)
    popularity = product.get("popularity", 0.5)
    if popularity >= 0.85:
        pattern = QUANTITY_PATTERNS['high_demand']
    elif popularity >= 0.70:
        pattern = QUANTITY_PATTERNS['medium_demand']
    elif popularity >= 0.55:
        pattern = QUANTITY_PATTERNS['low_demand']
    else:
        pattern = QUANTITY_PATTERNS['variable']
    is_weekend = date.weekday() >= 5
    seasonal_boost = calculate_seasonal_factor(date)
    # --- Weekday/Weekend zero bias ---
    if is_weekend and random.random() < 0.15:
        return 0
    if not is_weekend and random.random() < 0.03:
        return 0
    base_qty = random.choices(pattern['values'], weights=pattern['weights'])[0]
    # Heteroskedastic noise: scale by mean
    mean_qty = sum(pattern['values']) / len(pattern['values'])
    noisy_qty = int(round(base_qty + random.gauss(0, 0.15 * mean_qty)))
    final_qty = max(MIN_QUANTITY, min(MAX_QUANTITY, noisy_qty))
    return max(1, final_qty)

def get_demand_pattern(popularity: float, date: datetime) -> str:
    """Determine demand pattern based on popularity and date."""
    seasonal = calculate_seasonal_factor(date)
    is_weekend = date.weekday() >= 5
    
    # Adjust popularity based on context
    adjusted_popularity = popularity * seasonal
    if is_weekend:
        adjusted_popularity *= 1.2
    
    if adjusted_popularity >= 0.9:
        return 'high_demand'
    elif adjusted_popularity >= 0.7:
        return 'medium_demand'
    elif adjusted_popularity >= 0.5:
        return 'low_demand'
    else:
        return 'variable'

def add_realistic_noise(base_value: int, noise_factor: float = 0.15) -> int:
    """Add realistic noise to quantity values."""
    noise = random.uniform(-noise_factor, noise_factor)
    noisy_value = int(base_value * (1 + noise))
    return max(1, min(MAX_QUANTITY, noisy_value))

def get_season_from_date(date: datetime) -> str:
    """Determine season from date for seasonal discount codes."""
    month = date.month
    if month in [12, 1, 2]:
        return "winter"
    elif month in [3, 4, 5]:
        return "spring"
    elif month in [6, 7, 8]:
        return "summer"
    else:
        return "fall"

def generate_discount_code(date: datetime, discount_ratio: float, is_holiday: bool = False) -> str:
    """Generate realistic discount codes based on season, holidays, and discount amount."""
    if discount_ratio == 0.0:
        return ""
    
    # Get season and date context
    season = get_season_from_date(date)
    month = date.month
    is_weekend = date.weekday() >= 5
    
    # Define discount code patterns based on different contexts
    seasonal_codes = {
        "winter": ["WINTER", "HOLIDAY", "COZY", "WARMUP", "SNOW"],
        "spring": ["SPRING", "BLOOM", "FRESH", "EASTER", "RENEW"],
        "summer": ["SUMMER", "SUN", "BEACH", "VACATION", "HOT"],
        "fall": ["FALL", "AUTUMN", "HARVEST", "SCHOOL", "LEAF"]
    }
    
    holiday_codes = {
        1: ["NEWYEAR", "FRESH", "RESOLUTION"],
        2: ["VALENTINE", "LOVE", "HEARTS"],
        3: ["SPRING", "EASTER", "BLOOM"],
        4: ["EASTER", "SPRING", "BUNNY"],
        5: ["MOTHER", "MOM", "SPRING"],
        6: ["FATHER", "DAD", "SUMMER"],
        7: ["SUMMER", "JULY4", "FREEDOM"],
        8: ["SUMMER", "VACATION", "HOT"],
        9: ["BACK2SCHOOL", "AUTUMN", "LEARN"],
        10: ["HALLOWEEN", "SPOOKY", "FALL"],
        11: ["THANKSGIVING", "TURKEY", "GRATEFUL"],
        12: ["HOLIDAY", "XMAS", "WINTER"]
    }
    
    weekend_codes = ["WEEKEND", "RELAX", "FUNDAY", "CHILL"]
    
    # Discount amount-based prefixes
    if discount_ratio >= 0.40:
        amount_codes = ["MEGA", "SUPER", "HUGE", "BIG", "FLASH"]
    elif discount_ratio >= 0.25:
        amount_codes = ["GREAT", "AWESOME", "SPECIAL", "PRIME"]
    elif discount_ratio >= 0.15:
        amount_codes = ["SAVE", "DEAL", "GOOD", "NICE"]
    else:
        amount_codes = ["WELCOME", "TRY", "FIRST", "SMALL"]
    
    # Choose base code
    if is_holiday and month in holiday_codes:
        base_code = random.choice(holiday_codes[month])
    elif is_weekend and random.random() < 0.3:
        base_code = random.choice(weekend_codes)
    else:
        base_code = random.choice(seasonal_codes[season])
    
    # Add amount prefix 30% of the time
    if random.random() < 0.3:
        prefix = random.choice(amount_codes)
        code = f"{prefix}{base_code}"
    else:
        code = base_code
    
    # Add discount percentage as suffix
    discount_pct = int(discount_ratio * 100)
    
    # Add number suffix (percentage or random)
    if random.random() < 0.7:  # 70% chance to include actual percentage
        code += str(discount_pct)
    else:  # 30% chance for creative numbering
        if discount_ratio >= 0.40:
            code += random.choice(["50", "40", "MAX"])
        elif discount_ratio >= 0.25:
            code += random.choice(["25", "30", "PLUS"])
        else:
            code += random.choice(["15", "20", "NOW"])
    
    return code

def generate_discount_ratio(date: datetime, subtotal: float, total_quantity: int, is_holiday: bool = False) -> float:
    """Generate realistic discount ratio for Prophet training data."""
    if not ENABLE_DISCOUNTS or subtotal == 0:
        return 0.0
    
    # Base distribution with contextual adjustments
    base_ratios = list(DISCOUNT_RATIO_PROBABILITIES.keys())
    base_weights = list(DISCOUNT_RATIO_PROBABILITIES.values())
    
    # Adjust weights based on context
    adjusted_weights = base_weights.copy()
    
    # Increase probability of discounts on weekends
    if date.weekday() >= 5:  # Weekend
        # Shift probability from 0.0 to higher discount ratios
        for i in range(len(adjusted_weights)):
            if base_ratios[i] == 0.0:
                adjusted_weights[i] *= 0.8  # Reduce no-discount probability
            elif base_ratios[i] > 0.0:
                adjusted_weights[i] *= 1.3  # Increase discount probability
    
    # Increase probability of discounts on holidays
    if is_holiday:
        for i in range(len(adjusted_weights)):
            if base_ratios[i] == 0.0:
                adjusted_weights[i] *= 0.6  # Reduce no-discount probability more
            elif base_ratios[i] >= 0.20:
                adjusted_weights[i] *= 2.0  # Double higher discount probabilities
    
    # Bulk orders get more discounts
    if total_quantity >= 4:
        for i in range(len(adjusted_weights)):
            if base_ratios[i] == 0.0:
                adjusted_weights[i] *= 0.7
            elif base_ratios[i] >= 0.15:
                adjusted_weights[i] *= 1.5
    
    # Normalize weights
    total_weight = sum(adjusted_weights)
    normalized_weights = [w / total_weight for w in adjusted_weights]
    
    # Select discount ratio
    selected_ratio = random.choices(base_ratios, weights=normalized_weights, k=1)[0]
    
    # Round to 4 decimal places as specified
    return round(selected_ratio, 4)

def generate_realistic_discount(date: datetime, subtotal: float, total_quantity: int, is_holiday: bool = False) -> tuple:
    """Generate realistic discount ratio and amount for Prophet training data."""
    discount_ratio = generate_discount_ratio(date, subtotal, total_quantity, is_holiday)
    
    if discount_ratio == 0.0:
        return 0.0, 0.0
    
    # Calculate discount amount
    discount_amount = discount_ratio * subtotal
    
    return round(discount_ratio, 4), round(discount_amount, 2)

def apply_realism_layer_to_daily_orders(date: datetime, base_orders: int, sku: str) -> int:
    """Apply realism layer effects to daily order count."""
    if not ENABLE_REALISM_LAYER:
        return base_orders
    
    modified_orders = base_orders
    
    # System downtime - complete loss of orders
    if random.random() < SYSTEM_DOWNTIME_PROB:
        realism_state['system_downtime_periods'].append(date)
        return 0
    
    # Inventory stockouts - reduce orders significantly
    if sku in realism_state['stockout_products'] or random.random() < INVENTORY_STOCKOUT_PROB:
        realism_state['stockout_products'].add(sku)
        # Gradual recovery over 3-7 days
        recovery_factor = min(1.0, random.uniform(0.1, 0.3))
        modified_orders = int(base_orders * recovery_factor)
        
        # Random chance to recover from stockout
        if random.random() < 0.15:
            realism_state['stockout_products'].discard(sku)
    
    # Viral product spikes
    if sku in realism_state['viral_products'] or random.random() < VIRAL_SPIKE_PROB:
        if sku not in realism_state['viral_products']:
            realism_state['viral_products'].add(sku)
            print(f"🔥 Viral spike triggered for {sku} on {date.strftime('%Y-%m-%d')}")
        
        # Viral effect lasts 7-21 days with decay
        viral_multiplier = random.uniform(3.0, 12.0) * (1 - random.uniform(0, 0.15))
        modified_orders = int(base_orders * viral_multiplier)
        
        # Random chance for viral effect to end
        if random.random() < 0.05:
            realism_state['viral_products'].discard(sku)
    
    # Social media boost
    if random.random() < SOCIAL_MEDIA_BOOST_PROB:
        boost_multiplier = random.uniform(1.5, 3.2)
        modified_orders = int(base_orders * boost_multiplier)
    
    # Competitor impact drops
    if random.random() < COMPETITOR_IMPACT_PROB:
        drop_factor = random.uniform(0.3, 0.7)
        modified_orders = int(base_orders * drop_factor)
    
    # Supply chain disruptions
    if random.random() < SUPPLY_CHAIN_DISRUPTION_PROB:
        realism_state['supply_disruptions'].add(sku)
        disruption_factor = random.uniform(0.1, 0.4)
        modified_orders = int(base_orders * disruption_factor)
    
    # Marketing campaigns boost
    if random.random() < MARKETING_CAMPAIGN_PROB:
        campaign_info = {
            'sku': sku,
            'start_date': date,
            'duration': random.randint(3, 14),
            'boost': random.uniform(1.8, 4.5)
        }
        realism_state['marketing_campaigns'].append(campaign_info)
    
    # Apply active marketing campaign effects
    for campaign in realism_state['marketing_campaigns']:
        if (campaign['sku'] == sku and 
            campaign['start_date'] <= date <= campaign['start_date'] + timedelta(days=campaign['duration'])):
            modified_orders = int(modified_orders * campaign['boost'])
    
    # Flash sale effects
    if random.random() < FLASH_SALE_PROB:
        flash_multiplier = random.uniform(2.5, 8.0)
        modified_orders = int(base_orders * flash_multiplier)
    
    # External random events (news, trends, etc.)
    if random.random() < EXTERNAL_EVENT_PROB:
        event_multiplier = random.uniform(0.2, 4.0)  # Can be positive or negative
        modified_orders = int(base_orders * event_multiplier)
    
    # Seasonal trend deviations
    if random.random() < SEASONAL_DEVIATION:
        deviation_factor = random.uniform(0.6, 1.4)
        modified_orders = int(modified_orders * deviation_factor)
    
    return max(0, modified_orders)

def apply_data_quality_issues(order_data: Dict) -> Dict:
    """Apply realistic data quality issues to order data."""
    if not ENABLE_REALISM_LAYER:
        return order_data
    
    modified_order = order_data.copy()
    
    # Missing email addresses
    if random.random() < MISSING_EMAIL_PROB:
        modified_order["Email"] = ""
    
    # Missing phone numbers
    if random.random() < MISSING_PHONE_PROB:
        modified_order["Phone"] = ""
        modified_order["Billing Phone"] = ""
        modified_order["Shipping Phone"] = ""
    
    # Incomplete addresses
    if random.random() < INCOMPLETE_ADDRESS_PROB:
        # Randomly remove address components
        if random.random() < 0.5:
            modified_order["Billing Street"] = ""
            modified_order["Shipping Street"] = ""
        if random.random() < 0.3:
            modified_order["Billing Zip"] = ""
            modified_order["Shipping Zip"] = ""
        if random.random() < 0.2:
            modified_order["Billing Province"] = ""
            modified_order["Shipping Province"] = ""
    
    # Processing delays
    if random.random() < PROCESSING_DELAY_PROB:
        # Add delay between created and processed timestamps
        created_time = datetime.strptime(modified_order["Created at"], "%Y-%m-%d %H:%M:%S -0400")
        delay_hours = random.randint(2, 48)
        processed_time = created_time + timedelta(hours=delay_hours)
        modified_order["Processed at"] = processed_time.strftime("%Y-%m-%d %H:%M:%S -0400")
        realism_state['processing_delays'][modified_order["Name"]] = delay_hours
    
    # Fulfillment delays
    if random.random() < FULFILLMENT_DELAY_PROB:
        # Add extra delay for fulfillment
        created_time = datetime.strptime(modified_order["Created at"], "%Y-%m-%d %H:%M:%S -0400")
        delay_days = random.randint(3, 14)
        fulfilled_time = created_time + timedelta(days=delay_days)
        modified_order["Fulfilled at"] = fulfilled_time.strftime("%Y-%m-%d %H:%M:%S -0400")
        
        # Sometimes mark as unfulfilled if delay is too long
        if delay_days > 10 and random.random() < 0.3:
            modified_order["Fulfillment Status"] = "unfulfilled"
            modified_order["Fulfilled at"] = ""
    
    # Payment failures
    if random.random() < PAYMENT_FAILURE_PROB:
        modified_order["Financial Status"] = "pending"
        modified_order["Paid at"] = ""
        # Sometimes becomes authorized or refunded
        if random.random() < 0.6:
            modified_order["Financial Status"] = "authorized"
        elif random.random() < 0.2:
            modified_order["Financial Status"] = "refunded"
            modified_order["Refunded Amount"] = modified_order["Total"]
    
    return modified_order

def apply_technical_imperfections(order_data: Dict, order_counter: int) -> Dict:
    """Apply technical system imperfections to order data."""
    if not ENABLE_REALISM_LAYER:
        return order_data
    
    modified_order = order_data.copy()
    
    # Order ID gaps (simulating deleted orders, test orders, etc.)
    if random.random() < ORDER_ID_GAPS_PROB:
        gap_size = random.randint(1, 15)
        realism_state['order_id_counter'] += gap_size
    
    # Timestamp drift
    if random.random() < 0.3:
        drift_seconds = random.randint(-TIMESTAMP_DRIFT_SECONDS, TIMESTAMP_DRIFT_SECONDS)
        
        for timestamp_field in ["Created at", "Processed at", "Paid at", "Updated at"]:
            if modified_order[timestamp_field]:
                try:
                    original_time = datetime.strptime(modified_order[timestamp_field], "%Y-%m-%d %H:%M:%S -0400")
                    drifted_time = original_time + timedelta(seconds=drift_seconds)
                    modified_order[timestamp_field] = drifted_time.strftime("%Y-%m-%d %H:%M:%S -0400")
                except:
                    pass  # Skip if timestamp parsing fails
    
    # Rounding errors in monetary values
    if random.random() < ROUNDING_ERRORS_PROB:
        for money_field in ["Subtotal", "Shipping", "Taxes", "Total", "Discount Amount"]:
            if modified_order[money_field] and modified_order[money_field] != "0.00":
                try:
                    value = float(modified_order[money_field])
                    # Add small rounding error
                    error = random.uniform(-0.02, 0.02)
                    modified_order[money_field] = f"{value + error:.2f}"
                except:
                    pass
    
    # Timezone inconsistencies
    if random.random() < TIMEZONE_INCONSISTENCY_PROB:
        # Randomly change some timestamps to different timezone
        timezone_options = ["-0400", "-0500", "-0600", "-0700", "-0800", "+0000"]
        new_tz = random.choice(timezone_options)
        
        for timestamp_field in ["Created at", "Processed at", "Paid at"]:
            if modified_order[timestamp_field]:
                modified_order[timestamp_field] = modified_order[timestamp_field].replace("-0400", new_tz)
    
    return modified_order

def apply_merchant_behavior_effects(date: datetime, products: list) -> list:
    """Apply realistic merchant behavior effects like price changes, product launches."""
    if not ENABLE_REALISM_LAYER:
        return products
    
    modified_products = []
    
    for product in products:
        modified_product = product.copy()
        sku = product['sku']
        
        # Price adjustments
        if random.random() < PRICE_ADJUSTMENT_PROB:
            if sku not in realism_state['price_adjusted_products']:
                # First price adjustment
                price_change = random.uniform(0.85, 1.15)  # ±15%
                new_price = product['price'] * price_change
                modified_product['price'] = round(new_price, 2)
                realism_state['price_adjusted_products'][sku] = {
                    'original_price': product['price'],
                    'current_price': modified_product['price'],
                    'adjustment_date': date
                }
        
        # Product discontinuation
        if random.random() < DISCONTINUED_PRODUCT_PROB:
            # Skip this product (simulate discontinuation)
            continue
        
        modified_products.append(modified_product)
    
    # New product launches (add temporary products)
    if random.random() < NEW_PRODUCT_LAUNCH_PROB:
        new_product = {
            'name': f"New Trendy Toy {random.randint(1000, 9999)}",
            'price': random.uniform(15.99, 89.99),
            'sku': f"TOY-NEW-{random.randint(100, 999)}",
            'vendor': random.choice(["TrendyToys Inc", "Innovation Toys", "NextGen Play"]),
            'popularity': random.uniform(0.2, 0.8),
            'trend': 'growing'
        }
        modified_products.append(new_product)
    
    return modified_products

def generate_b2b_bulk_order(customer_info: Dict, products: list, date: datetime) -> List[Dict]:
    """Generate realistic B2B bulk orders with different characteristics."""
    if not ENABLE_REALISM_LAYER or random.random() > BULK_B2B_ORDER_PROB:
        return []
    
    # B2B customers buy in bulk
    bulk_orders = []
    realism_state['b2b_customers'].add(customer_info['email'])
    
    # Select 1-3 products for bulk purchase
    selected_products = random.sample(products, min(random.randint(1, 3), len(products)))
    
    for product in selected_products:
        # B2B quantities are much higher
        quantity = random.randint(20, 100)
        
        # B2B gets better discounts
        b2b_discount_ratio = random.uniform(0.15, 0.35)
        
        # Create bulk order (simplified structure)
        bulk_order = {
            'sku': product['sku'],
            'quantity': quantity,
            'unit_price': product['price'],
            'discount_ratio': b2b_discount_ratio,
            'customer_type': 'B2B',
            'date': date
        }
        bulk_orders.append(bulk_order)
    
    return bulk_orders

# Technical Imperfections Configuration
TIMESTAMP_DRIFT_SECONDS = CONFIG.get('realism_layer', {}).get('technical_imperfections', {}).get('timestamp_drift_seconds', 300)
ORDER_ID_GAPS_PROB = CONFIG.get('realism_layer', {}).get('technical_imperfections', {}).get('order_id_gaps_probability', 0.01)
DUPLICATE_SKU_ENTRIES_PROB = CONFIG.get('realism_layer', {}).get('technical_imperfections', {}).get('duplicate_sku_entries_probability', 0.002)
ROUNDING_ERRORS_PROB = CONFIG.get('realism_layer', {}).get('technical_imperfections', {}).get('rounding_errors_probability', 0.05)
TIMEZONE_INCONSISTENCY_PROB = CONFIG.get('realism_layer', {}).get('technical_imperfections', {}).get('timezone_inconsistency_probability', 0.03)
EXPORT_CORRUPTION_PROB = CONFIG.get('realism_layer', {}).get('technical_imperfections', {}).get('export_corruption_probability', 0.001)

# Quantity patterns based on product popularity and demand
QUANTITY_PATTERNS = {
    'high_demand': {'weights': [0.03, 0.12, 0.25, 0.30, 0.20, 0.08, 0.02], 'values': [0, 1, 2, 3, 4, 5, 6]},
    'medium_demand': {'weights': [0.05, 0.20, 0.35, 0.25, 0.12, 0.03], 'values': [0, 1, 2, 3, 4, 5]},
    'low_demand': {'weights': [0.15, 0.40, 0.25, 0.15, 0.05], 'values': [0, 1, 2, 3, 4]},
    'variable': {'weights': [0.10, 0.18, 0.22, 0.20, 0.15, 0.10, 0.05], 'values': [0, 1, 2, 3, 4, 5, 6]}
}

# Realism Layer State Tracking
realism_state = {
    'viral_products': set(),
    'stockout_products': set(),
    'price_adjusted_products': {},
    'system_downtime_periods': [],
    'marketing_campaigns': [],
    'supply_disruptions': set(),
    'order_id_counter': 1000,
    'processing_delays': {},
    'b2b_customers': set()
}

# Toy Products Database - dynamically generated based on config
def generate_toy_products(num_skus):
    """Generate toy products list based on the configured number of SKUs."""
    
    # Base product templates to use for generation
    base_products = [
        {"name": "LEGO Classic Creative Bricks", "price": 29.99, "sku": "TOY-LEGO-001", "vendor": "LEGO Group", "popularity": 0.95, "trend": "stable"},
        {"name": "Barbie Dreamhouse Playset", "price": 199.99, "sku": "TOY-BARB-001", "vendor": "Mattel", "popularity": 0.85, "trend": "growing"},
        {"name": "Hot Wheels Track Builder", "price": 34.99, "sku": "TOY-HW-001", "vendor": "Mattel", "popularity": 0.90, "trend": "stable"},
        {"name": "Monopoly Board Game", "price": 24.99, "sku": "TOY-MONO-001", "vendor": "Hasbro", "popularity": 0.88, "trend": "stable"},
        {"name": "Nerf Elite Blaster", "price": 19.99, "sku": "TOY-NERF-001", "vendor": "Hasbro", "popularity": 0.92, "trend": "growing"},
        {"name": "Play-Doh Creative Set", "price": 15.99, "sku": "TOY-PD-001", "vendor": "Hasbro", "popularity": 0.89, "trend": "stable"},
        {"name": "Fisher-Price Rock-a-Stack", "price": 8.99, "sku": "TOY-FP-001", "vendor": "Fisher-Price", "popularity": 0.75, "trend": "declining"},
        {"name": "Crayola Art Supplies Kit", "price": 22.99, "sku": "TOY-CRAY-001", "vendor": "Crayola", "popularity": 0.82, "trend": "stable"},
        {"name": "Rubik's Cube Classic", "price": 12.99, "sku": "TOY-RUB-001", "vendor": "Spin Master", "popularity": 0.70, "trend": "volatile"},
        {"name": "Transformers Action Figure", "price": 29.99, "sku": "TOY-TRANS-001", "vendor": "Hasbro", "popularity": 0.78, "trend": "stable"},
        {"name": "Pokémon Trading Cards", "price": 4.99, "sku": "TOY-POKE-001", "vendor": "Pokémon Company", "popularity": 0.95, "trend": "growing"},
        {"name": "My Little Pony Figure", "price": 16.99, "sku": "TOY-MLP-001", "vendor": "Hasbro", "popularity": 0.72, "trend": "declining"},
        {"name": "Thomas & Friends Train Set", "price": 39.99, "sku": "TOY-THOMAS-001", "vendor": "Mattel", "popularity": 0.68, "trend": "declining"},
        {"name": "Minecraft Building Set", "price": 44.99, "sku": "TOY-MC-001", "vendor": "LEGO Group", "popularity": 0.87, "trend": "growing"},
        {"name": "Scrabble Junior", "price": 19.99, "sku": "TOY-SCRAB-001", "vendor": "Hasbro", "popularity": 0.60, "trend": "stable"},
        {"name": "UNO Card Game", "price": 7.99, "sku": "TOY-UNO-001", "vendor": "Mattel", "popularity": 0.85, "trend": "stable"},
        {"name": "Jenga Classic Game", "price": 9.99, "sku": "TOY-JENGA-001", "vendor": "Hasbro", "popularity": 0.80, "trend": "stable"},
        {"name": "Peppa Pig Playhouse", "price": 54.99, "sku": "TOY-PEPPA-001", "vendor": "Character Options", "popularity": 0.65, "trend": "declining"},
        {"name": "Disney Princess Doll", "price": 24.99, "sku": "TOY-DISNEY-001", "vendor": "Mattel", "popularity": 0.83, "trend": "stable"},
        {"name": "Spider-Man Action Figure", "price": 18.99, "sku": "TOY-SPIDER-001", "vendor": "Hasbro", "popularity": 0.86, "trend": "growing"},
        {"name": "Frozen Elsa Dress-Up", "price": 32.99, "sku": "TOY-FROZEN-001", "vendor": "Disney", "popularity": 0.81, "trend": "declining"},
        {"name": "Cars Lightning McQueen", "price": 21.99, "sku": "TOY-CARS-001", "vendor": "Mattel", "popularity": 0.77, "trend": "stable"},
        {"name": "Paw Patrol Rescue Vehicle", "price": 26.99, "sku": "TOY-PAW-001", "vendor": "Spin Master", "popularity": 0.84, "trend": "growing"},
        {"name": "Baby Alive Interactive Doll", "price": 49.99, "sku": "TOY-BABY-001", "vendor": "Hasbro", "popularity": 0.69, "trend": "stable"},
        {"name": "Magic 8 Ball", "price": 11.99, "sku": "TOY-MAGIC-001", "vendor": "Mattel", "popularity": 0.55, "trend": "stable"},
                "Updated at": "",
                "Lineitem product id": "",
            }
        
        line_items.append(line_item)
    
    return line_items

def ensure_minimum_sku_distribution(all_orders: List[Dict], start_date: datetime, end_date: datetime) -> List[Dict]:
    """Ensure all SKUs meet minimum requirements for Prophet model compatibility."""
    if not ENSURE_SKU_DISTRIBUTION:
        return all_orders
    
    print("🔍 Analyzing SKU distribution for Prophet compatibility...")
    
    # Count sales per SKU
    sku_sales = {}
    sku_dates = {}
    
    for order in all_orders:
        sku = order.get("Lineitem sku", "")
        date_str = order.get("Created at", "")
        quantity = int(order.get("Lineitem quantity", 1))
        
        if sku and date_str:
            date = datetime.strptime(date_str.split()[0], "%Y-%m-%d")
            
            if sku not in sku_sales:
                sku_sales[sku] = 0
                sku_dates[sku] = set()
            
            sku_sales[sku] += quantity
            sku_dates[sku].add(date.strftime("%Y-%m-%d"))
    
    # Find SKUs that need more sales
    skus_needing_boost = []
    
    for product in TOY_PRODUCTS:
        sku = product["sku"]
        total_units = sku_sales.get(sku, 0)
        unique_days = len(sku_dates.get(sku, set()))
        
        if total_units < MIN_TOTAL_UNITS_PER_SKU or unique_days < MIN_SALES_DAYS_PER_SKU:
            needed_units = max(0, MIN_TOTAL_UNITS_PER_SKU - total_units)
            needed_days = max(0, MIN_SALES_DAYS_PER_SKU - unique_days)
            skus_needing_boost.append({
                "product": product,
                "needed_units": needed_units,
                "needed_days": needed_days,
                "current_units": total_units,
                "current_days": unique_days
            })
    
    if skus_needing_boost:
        print(f"📈 Boosting {len(skus_needing_boost)} SKUs to meet Prophet requirements...")
        
        # Generate additional orders for under-performing SKUs
        additional_orders = []
        next_order_id = max(int(order.get("Name", "#0").replace("#", "")) for order in all_orders if order.get("Name", "").startswith("#")) + 1
        
        for sku_info in skus_needing_boost:
            product = sku_info["product"]
            needed_units = sku_info["needed_units"]
            needed_days = sku_info["needed_days"]
            
            # Generate sales across random dates to meet minimum day requirement
            total_days = (end_date - start_date).days
            date_range = [start_date + timedelta(days=i) for i in range(total_days)]
            selected_dates = random.sample(date_range, min(needed_days, len(date_range)))
            
            units_per_date = max(1, needed_units // max(1, len(selected_dates)))
            
            for date in selected_dates:
                # Create a focused order with just this SKU
                quantity = min(3, units_per_date + random.randint(0, 2))
                customer = generate_customer_info()
                
                created_at = date + timedelta(
                    hours=random.randint(8, 22),
                    minutes=random.randint(0, 59)
                )
                
                # Calculate discount for this additional order
                subtotal = product['price'] * quantity
                is_holiday = date in get_us_holidays(start_date, end_date) if start_date and end_date else False
                discount_ratio, discount_amount = generate_realistic_discount(date, subtotal, quantity, is_holiday)
                
                # Generate discount code if there's a discount
                discount_code = generate_discount_code(date, discount_ratio, discount_amount) if discount_amount > 0 else ""
                
                # Apply discount
                discounted_subtotal = subtotal - discount_amount
                shipping_cost = 0.0 if discounted_subtotal > 50 else 5.99
                taxes = discounted_subtotal * 0.08
                total = discounted_subtotal + shipping_cost + taxes
                
                # Single line item order focused on the needed SKU
                line_item = {
                    "Name": f"#{next_order_id}",
                    "Email": customer["email"],
                    "Financial Status": "paid",
                    "Paid at": created_at.strftime("%Y-%m-%d %H:%M:%S -0400"),
                    "Fulfillment Status": "fulfilled", 
                    "Fulfilled at": (created_at + timedelta(hours=random.randint(1, 24))).strftime("%Y-%m-%d %H:%M:%S -0400"),
                    "Accepts Marketing": random.choice(["yes", "no"]),
                    "Currency": "USD",
                    "Subtotal": f"{subtotal:.2f}",
                    "Shipping": f"{shipping_cost:.2f}",
                    "Taxes": f"{taxes:.2f}",
                    "Total": f"{total:.2f}",
                    "Discount Code": discount_code,  # Use generated discount code
                    "Discount Amount": f"{discount_amount:.2f}",
                    "discount_ratio": f"{discount_ratio:.4f}",  # New field for Prophet
                    "Shipping Method": "Standard",
                    "Created at": created_at.strftime("%Y-%m-%d %H:%M:%S -0400"),
                    "Updated at": created_at.strftime("%Y-%m-%d %H:%M:%S -0400"),
                    "Processed at": created_at.strftime("%Y-%m-%d %H:%M:%S -0400"),
                    "Customer": customer["name"],
                    "Shipping Name": customer["name"],
                    "Billing Name": customer["name"],
                    "Shipping Street": customer["address"]["street"],
                    "Shipping City": customer["address"]["city"],
                    "Shipping Zip": customer["address"]["zip"],
                    "Shipping Province": customer["address"]["province"],
                    "Shipping Country": customer["address"]["country"],
                    "Billing Street": customer["address"]["street"],
                    "Billing City": customer["address"]["city"], 
                    "Billing Zip": customer["address"]["zip"],
                    "Billing Province": customer["address"]["province"],
                    "Billing Country": customer["address"]["country"],
                    "Notes": "",
                    "Note Attributes": "",
                    "Cancelled at": "",
                    "Payment Method": "Credit Card",
                    "Payment Reference": generate_random_id(),
                    "Refunded Amount": "",
                    "Vendor": product["vendor"],
                    "Outstanding Balance": "",
                    "Employee": "",
                    "Location": "",
                    "Device ID": "",
                    "Id": "",
                    "Tags": "",
                    "Risk Level": "",
                    "Source": "",
                    "Lineitem discount": "0.00",
                    "Tax 1 Name": "",
                    "Tax 1 Value": "",
                    "Tax 2 Name": "",
                    "Tax 2 Value": "",
                    "Tax 3 Name": "",
                    "Tax 3 Value": "",
                    "Tax 4 Name": "",
                    "Tax 4 Value": "",
                    "Tax 5 Name": "",
                    "Tax 5 Value": "",
                    "Phone": customer["phone"],
                    "Receipt Number": "",
                    "Duties": "",
                    "Billing Province Name": "",
                    "Shipping Province Name": "",
                    "Payment ID": "",
                    "Payment Terms Name": "",
                    "Next Payment Due At": "",
                    "Payment References": "",
                    "Lineitem variant id": "",
                    "Lineitem product id": "",
                    "Lineitem name": product["name"],
                    "Lineitem variant": "",
                    "Lineitem sku": product["sku"],
                    "Lineitem requires shipping": "TRUE",
                    "Lineitem taxable": "TRUE",
                    "Lineitem fulfillment status": "fulfilled",
                    "Lineitem price": f"{product['price']:.2f}",
                    "Lineitem compare at price": "",
                    "Lineitem quantity": str(quantity),
                    "Lineitem grams": "500"
                }
                
                additional_orders.append(line_item)
                next_order_id += 1
                
                needed_units -= quantity
                if needed_units <= 0:
                    break
        
        print(f"➕ Added {len(additional_orders)} additional orders for SKU distribution")
        all_orders.extend(additional_orders)
    
    return all_orders

def generate_synthetic_data():
    """Generate the complete synthetic dataset with advanced realism: event spikes, trend drift, heteroskedastic noise, and improved smoothing."""
    print("🚀 Starting synthetic toy sales data generation...")
    print(f"📊 Configuration:")
    print(f"   - Number of SKUs (from config): {NUMBER_OF_SKUS}")
    print(f"   - Months to generate: {NUMBER_OF_MONTHS}")
    print(f"   - Average monthly growth: {AVERAGE_MONTHLY_GROWTH*100:.1f}%")
    print(f"   - Weekend boost factor: {WEEKEND_BOOST_FACTOR}x")
    print(f"   - Base daily orders: {BASE_DAILY_ORDERS}")
    print(f"   - Total toy products generated: {len(TOY_PRODUCTS)}")
    end_date = datetime.now() - timedelta(days=1)
    start_date = end_date - timedelta(days=30 * NUMBER_OF_MONTHS)
    print(f"📅 Date range: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")
    print(f"📊 Generating data for {(end_date - start_date).days} days")
    all_orders = []
    total_orders_generated = 0
    us_holiday_dates = get_us_holidays(start_date, end_date)
    current_date = start_date
    month_index = 0
    last_month = start_date.month
    prev_orders = None
    # Assign a random trend to each SKU for drift
    sku_trends = {p['sku']: random.uniform(-0.02, 0.04) for p in TOY_PRODUCTS}
    sku_means = {p['sku']: p.get('popularity', 0.5) * 15 + 5 for p in TOY_PRODUCTS}
    while current_date <= end_date:
        if random.random() < 0.02:
            current_date += timedelta(days=1)
            prev_orders = None
            continue
        if current_date.month != last_month:
            month_index += 1
            last_month = current_date.month
        rep_product = random.choice(TOY_PRODUCTS)
        rep_sku = rep_product["sku"]
        trend = sku_trends[rep_sku]
        mean_sales = sku_means[rep_sku]
        daily_orders = calculate_daily_orders(current_date, month_index, us_holiday_dates, prev_orders, rep_sku, trend, mean_sales)
        if random.random() < 0.02:
            daily_orders = 0
        prev_orders = daily_orders
        for _ in range(daily_orders):
            order_id = generate_order_id()
            order_line_items = generate_order_data(current_date, order_id, start_date, us_holiday_dates)
            if random.random() < 0.01 and order_line_items:
                order_line_items[0]["Financial Status"] = "refunded"
                order_line_items[0]["Total"] = "0.00"
            all_orders.extend(order_line_items)
            total_orders_generated += 1
        if current_date.day == 1:
            print(f"📅 Processing {current_date.strftime('%B %Y')} - Orders so far: {total_orders_generated}")
        current_date += timedelta(days=1)
    all_orders = ensure_minimum_sku_distribution(all_orders, start_date, end_date)
    output_filename = f"toy_sales_synthetic_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    if all_orders:
        # Define the specific column order as requested
        fieldnames = [
            "Name", "Email", "Financial Status", "Paid at", "Fulfillment Status", "Fulfilled at",
            "Accepts Marketing", "Currency", "Subtotal", "Shipping", "Taxes", "Total", "Discount Code",
            "Discount Amount", "discount_ratio", "Shipping Method", "Created at", "Lineitem quantity", "Lineitem name",
            "Lineitem price", "Lineitem compare at price", "Lineitem sku", "Lineitem requires shipping",
            "Lineitem taxable", "Lineitem fulfillment status", "Billing Name", "Billing Street",
            "Billing Address1", "Billing Address2", "Billing Company", "Billing City", "Billing Zip",
            "Billing Province", "Billing Country", "Billing Phone", "Shipping Name", "Shipping Street",
            "Shipping Address1", "Shipping Address2", "Shipping Company", "Shipping City", "Shipping Zip",
            "Shipping Province", "Shipping Country", "Shipping Phone", "Notes", "Note Attributes",
            "Cancelled at", "Payment Method", "Payment Reference", "Refunded Amount", "Vendor",
            "Outstanding Balance", "Employee", "Location", "Device ID", "Id", "Tags", "Risk Level",
            "Source", "Lineitem discount", "Tax 1 Name", "Tax 1 Value", "Tax 2 Name", "Tax 2 Value",
            "Tax 3 Name", "Tax 3 Value", "Tax 4 Name", "Tax 4 Value", "Tax 5 Name", "Tax 5 Value",
            "Phone", "Receipt Number", "Duties", "Billing Province Name", "Shipping Province Name",
            "Payment ID", "Payment Terms Name", "Next Payment Due At", "Payment References", 
            "is_weekend", "is_holiday", "stockout", "Lineitem grams", "Lineitem variant id", 
            "Processed at", "Customer", "Lineitem variant", "Updated at", "Lineitem product id"
        ]

        with open(output_filename, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(all_orders)
    print(f"✅ Data generation complete!")
    print(f"📁 Output file: {output_filename}")
    print(f"🎯 Total orders generated: {total_orders_generated}")
    print(f"📋 Total line items: {len(all_orders)}")
    print(f"💰 Estimated total revenue: ${sum(float(order['Total']) for order in all_orders if order['Total']):.2f}")

if __name__ == "__main__":
    generate_synthetic_data()
